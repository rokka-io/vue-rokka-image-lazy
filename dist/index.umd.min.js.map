{"version":3,"file":"index.umd.min.js","sources":["../node_modules/lozad/dist/lozad.es.js","../node_modules/style-inject/dist/style-inject.es.js","../node_modules/vue-runtime-helpers/dist/index.mjs","../src/Img.vue","../src/index.js"],"sourcesContent":["/*! lozad.js - v1.14.0 - 2019-10-19\n* https://github.com/ApoorvSaxena/lozad.js\n* Copyright (c) 2019 Apoorv Saxena; Licensed MIT */\n\n\n/**\n * Detect IE browser\n * @const {boolean}\n * @private\n */\nconst isIE = typeof document !== 'undefined' && document.documentMode;\n\nconst defaultConfig = {\n  rootMargin: '0px',\n  threshold: 0,\n  load(element) {\n    if (element.nodeName.toLowerCase() === 'picture') {\n      const img = document.createElement('img');\n      if (isIE && element.getAttribute('data-iesrc')) {\n        img.src = element.getAttribute('data-iesrc');\n      }\n\n      if (element.getAttribute('data-alt')) {\n        img.alt = element.getAttribute('data-alt');\n      }\n\n      element.append(img);\n    }\n\n    if (element.nodeName.toLowerCase() === 'video' && !element.getAttribute('data-src')) {\n      if (element.children) {\n        const childs = element.children;\n        let childSrc;\n        for (let i = 0; i <= childs.length - 1; i++) {\n          childSrc = childs[i].getAttribute('data-src');\n          if (childSrc) {\n            childs[i].src = childSrc;\n          }\n        }\n\n        element.load();\n      }\n    }\n\n    if (element.getAttribute('data-src')) {\n      element.src = element.getAttribute('data-src');\n    }\n\n    if (element.getAttribute('data-srcset')) {\n      element.setAttribute('srcset', element.getAttribute('data-srcset'));\n    }\n\n    if (element.getAttribute('data-background-image')) {\n      element.style.backgroundImage = `url('${element.getAttribute('data-background-image').split(',').join('\\'),url(\\'')}')`;\n    } else if (element.getAttribute('data-background-image-set')) {\n      const imageSetLinks = element.getAttribute('data-background-image-set').split(',');\n      let firstUrlLink = (imageSetLinks[0].substr(0, imageSetLinks[0].indexOf(' ')) || imageSetLinks[0]); // Substring before ... 1x\n      firstUrlLink = firstUrlLink.indexOf('url(') === -1 ? `url(${firstUrlLink})` : firstUrlLink;\n      if (imageSetLinks.length === 1) {\n        element.style.backgroundImage = firstUrlLink;\n      } else {\n        element.setAttribute('style', (element.getAttribute('style') || '') + `background-image: ${firstUrlLink}; background-image: -webkit-image-set(${imageSetLinks}); background-image: image-set(${imageSetLinks})`);\n      }\n    }\n\n    if (element.getAttribute('data-toggle-class')) {\n      element.classList.toggle(element.getAttribute('data-toggle-class'));\n    }\n  },\n  loaded() {}\n};\n\nfunction markAsLoaded(element) {\n  element.setAttribute('data-loaded', true);\n}\n\nconst isLoaded = element => element.getAttribute('data-loaded') === 'true';\n\nconst onIntersection = (load, loaded) => (entries, observer) => {\n  entries.forEach(entry => {\n    if (entry.intersectionRatio > 0 || entry.isIntersecting) {\n      observer.unobserve(entry.target);\n\n      if (!isLoaded(entry.target)) {\n        load(entry.target);\n        markAsLoaded(entry.target);\n        loaded(entry.target);\n      }\n    }\n  });\n};\n\nconst getElements = (selector, root = document) => {\n  if (selector instanceof Element) {\n    return [selector]\n  }\n\n  if (selector instanceof NodeList) {\n    return selector\n  }\n\n  return root.querySelectorAll(selector)\n};\n\nfunction lozad (selector = '.lozad', options = {}) {\n  const {root, rootMargin, threshold, load, loaded} = Object.assign({}, defaultConfig, options);\n  let observer;\n\n  if (typeof window !== 'undefined' && window.IntersectionObserver) {\n    observer = new IntersectionObserver(onIntersection(load, loaded), {\n      root,\n      rootMargin,\n      threshold\n    });\n  }\n\n  return {\n    observe() {\n      const elements = getElements(selector, root);\n\n      for (let i = 0; i < elements.length; i++) {\n        if (isLoaded(elements[i])) {\n          continue\n        }\n\n        if (observer) {\n          observer.observe(elements[i]);\n          continue\n        }\n\n        load(elements[i]);\n        markAsLoaded(elements[i]);\n        loaded(elements[i]);\n      }\n    },\n    triggerLoad(element) {\n      if (isLoaded(element)) {\n        return\n      }\n\n      load(element);\n      markAsLoaded(element);\n      loaded(element);\n    },\n    observer\n  }\n}\n\nexport default lozad;\n","function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {\r\n    if (typeof shadowMode !== 'boolean') {\r\n        createInjectorSSR = createInjector;\r\n        createInjector = shadowMode;\r\n        shadowMode = false;\r\n    }\r\n    // Vue.extend constructor export interop.\r\n    const options = typeof script === 'function' ? script.options : script;\r\n    // render functions\r\n    if (template && template.render) {\r\n        options.render = template.render;\r\n        options.staticRenderFns = template.staticRenderFns;\r\n        options._compiled = true;\r\n        // functional template\r\n        if (isFunctionalTemplate) {\r\n            options.functional = true;\r\n        }\r\n    }\r\n    // scopedId\r\n    if (scopeId) {\r\n        options._scopeId = scopeId;\r\n    }\r\n    let hook;\r\n    if (moduleIdentifier) {\r\n        // server build\r\n        hook = function (context) {\r\n            // 2.3 injection\r\n            context =\r\n                context || // cached call\r\n                    (this.$vnode && this.$vnode.ssrContext) || // stateful\r\n                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional\r\n            // 2.2 with runInNewContext: true\r\n            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\r\n                context = __VUE_SSR_CONTEXT__;\r\n            }\r\n            // inject component styles\r\n            if (style) {\r\n                style.call(this, createInjectorSSR(context));\r\n            }\r\n            // register component module identifier for async chunk inference\r\n            if (context && context._registeredComponents) {\r\n                context._registeredComponents.add(moduleIdentifier);\r\n            }\r\n        };\r\n        // used by ssr in case component is cached and beforeCreate\r\n        // never gets called\r\n        options._ssrRegister = hook;\r\n    }\r\n    else if (style) {\r\n        hook = shadowMode\r\n            ? function (context) {\r\n                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));\r\n            }\r\n            : function (context) {\r\n                style.call(this, createInjector(context));\r\n            };\r\n    }\r\n    if (hook) {\r\n        if (options.functional) {\r\n            // register for functional component in vue file\r\n            const originalRender = options.render;\r\n            options.render = function renderWithStyleInjection(h, context) {\r\n                hook.call(context);\r\n                return originalRender(h, context);\r\n            };\r\n        }\r\n        else {\r\n            // inject component registration as beforeCreate hook\r\n            const existing = options.beforeCreate;\r\n            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\r\n        }\r\n    }\r\n    return script;\r\n}\n\nconst isOldIE = typeof navigator !== 'undefined' &&\r\n    /msie [6-9]\\\\b/.test(navigator.userAgent.toLowerCase());\r\nfunction createInjector(context) {\r\n    return (id, style) => addStyle(id, style);\r\n}\r\nlet HEAD;\r\nconst styles = {};\r\nfunction addStyle(id, css) {\r\n    const group = isOldIE ? css.media || 'default' : id;\r\n    const style = styles[group] || (styles[group] = { ids: new Set(), styles: [] });\r\n    if (!style.ids.has(id)) {\r\n        style.ids.add(id);\r\n        let code = css.source;\r\n        if (css.map) {\r\n            // https://developer.chrome.com/devtools/docs/javascript-debugging\r\n            // this makes source maps inside style tags work properly in Chrome\r\n            code += '\\n/*# sourceURL=' + css.map.sources[0] + ' */';\r\n            // http://stackoverflow.com/a/26603875\r\n            code +=\r\n                '\\n/*# sourceMappingURL=data:application/json;base64,' +\r\n                    btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) +\r\n                    ' */';\r\n        }\r\n        if (!style.element) {\r\n            style.element = document.createElement('style');\r\n            style.element.type = 'text/css';\r\n            if (css.media)\r\n                style.element.setAttribute('media', css.media);\r\n            if (HEAD === undefined) {\r\n                HEAD = document.head || document.getElementsByTagName('head')[0];\r\n            }\r\n            HEAD.appendChild(style.element);\r\n        }\r\n        if ('styleSheet' in style.element) {\r\n            style.styles.push(code);\r\n            style.element.styleSheet.cssText = style.styles\r\n                .filter(Boolean)\r\n                .join('\\n');\r\n        }\r\n        else {\r\n            const index = style.ids.size - 1;\r\n            const textNode = document.createTextNode(code);\r\n            const nodes = style.element.childNodes;\r\n            if (nodes[index])\r\n                style.element.removeChild(nodes[index]);\r\n            if (nodes.length)\r\n                style.element.insertBefore(textNode, nodes[index]);\r\n            else\r\n                style.element.appendChild(textNode);\r\n        }\r\n    }\r\n}\n\nfunction createInjectorSSR(context) {\r\n    if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\r\n        context = __VUE_SSR_CONTEXT__;\r\n    }\r\n    if (!context)\r\n        return () => { };\r\n    if (!('styles' in context)) {\r\n        context._styles = context._styles || {};\r\n        Object.defineProperty(context, 'styles', {\r\n            enumerable: true,\r\n            get: () => context._renderStyles(context._styles)\r\n        });\r\n        context._renderStyles = context._renderStyles || renderStyles;\r\n    }\r\n    return (id, style) => addStyle$1(id, style, context);\r\n}\r\nfunction addStyle$1(id, css, context) {\r\n    const group = process.env.NODE_ENV === 'production' ? css.media || 'default' : id;\r\n    const style = context._styles[group] || (context._styles[group] = { ids: [], css: '' });\r\n    if (!style.ids.includes(id)) {\r\n        style.media = css.media;\r\n        style.ids.push(id);\r\n        let code = css.source;\r\n        if (process.env.NODE_ENV !== 'production' && css.map) {\r\n            // https://developer.chrome.com/devtools/docs/javascript-debugging\r\n            // this makes source maps inside style tags work properly in Chrome\r\n            code += '\\n/*# sourceURL=' + css.map.sources[0] + ' */';\r\n            // http://stackoverflow.com/a/26603875\r\n            code +=\r\n                '\\n/*# sourceMappingURL=data:application/json;base64,' +\r\n                    Buffer.from(unescape(encodeURIComponent(JSON.stringify(css.map)))).toString('base64') +\r\n                    ' */';\r\n        }\r\n        style.css += code + '\\n';\r\n    }\r\n}\r\nfunction renderStyles(styles) {\r\n    let css = '';\r\n    for (const key in styles) {\r\n        const style = styles[key];\r\n        css +=\r\n            '<style data-vue-ssr-id=\"' +\r\n                Array.from(style.ids).join(' ') +\r\n                '\"' +\r\n                (style.media ? ' media=\"' + style.media + '\"' : '') +\r\n                '>' +\r\n                style.css +\r\n                '</style>';\r\n    }\r\n    return css;\r\n}\n\nfunction createInjector$1(context, shadowRoot) {\r\n    return (id, style) => addStyle$2(style, shadowRoot);\r\n}\r\nfunction createStyleElement(shadowRoot) {\r\n    var styleElement = document.createElement('style');\r\n    styleElement.type = 'text/css';\r\n    shadowRoot.appendChild(styleElement);\r\n    return styleElement;\r\n}\r\nfunction addStyle$2(css, shadowRoot) {\r\n    const styleElement = createStyleElement(shadowRoot);\r\n    if (css.media)\r\n        styleElement.setAttribute('media', css.media);\r\n    if ('styleSheet' in styleElement) {\r\n        styleElement.styleSheet.cssText = css.source;\r\n    }\r\n    else {\r\n        while (styleElement.firstChild) {\r\n            styleElement.removeChild(styleElement.firstChild);\r\n        }\r\n        styleElement.appendChild(document.createTextNode(css.source));\r\n    }\r\n}\n\nexport { normalizeComponent, createInjector, createInjectorSSR, createInjector$1 as createInjectorShadow };\n//# sourceMappingURL=index.mjs.map\n","<template>\n  <rokka-image-img\n    :org=\"org\"\n    :hash=\"hash\"\n    :filename=\"filename\"\n    :stack=\"stack\"\n    :format=\"format\"\n    :alt=\"alt\"\n    srcset-attribute=\"data-srcset\"\n    src-attribute=\"data-src\"\n    src-additional-attribute=\"src\"\n    :src-additional=\"srcAdditionalComputed\"\n    :postfix=\"postfix\"\n    :options=\"options\"\n  />\n</template>\n\n<script>\nimport { RokkaImageImg, buildRokkaUrl } from 'vue-rokka-image'\nimport lozad from 'lozad'\n\nclass ImageCache {\n  constructor({ max }) {\n    this.options = {\n      max: max || 100,\n    }\n    this._caches = []\n  }\n\n  has(key) {\n    return this._caches.indexOf(key) > -1\n  }\n\n  add(key) {\n    if (this.has(key)) return\n    this._caches.push(key)\n    if (this._caches.length > this.options.max) {\n      this.free()\n    }\n  }\n\n  free() {\n    this._caches.shift()\n  }\n}\n\nexport default {\n  name: 'RokkaImageImgLazy',\n  components: {\n    RokkaImageImg,\n  },\n  props: {\n    ...RokkaImageImg.props,\n    srcAttribute: {\n      type: String,\n      default: 'data-src',\n    },\n    srcsetAttribute: {\n      type: String,\n      default: 'data-srcset',\n    },\n    postfix: {\n      type: [Object, Array],\n      default: () => ['1x', '2x'],\n    },\n    options: {\n      type: [Object, Array],\n      default: () => [{ dpr: '1' }, { dpr: '2' }],\n    },\n    loading: {\n      type: String,\n      default: null,\n    },\n  },\n  computed: {\n    srcAdditionalComputed() {\n      if (!this.loading || this.isCached) {\n        return 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='\n      }\n      window._imageCache.add(this.rokkaRenderUrl)\n      return this.loading\n    },\n\n    isCached() {\n      return window._imageCache.has(this.rokkaRenderUrl)\n    },\n\n    rokkaRenderUrl() {\n      return buildRokkaUrl({\n        org: this.org,\n        hash: this.hash,\n        stack: this.stack,\n        format: this.format,\n        filename: this.filename,\n        options: Array.isArray(this.options) ? this.options[0] : this.options,\n        variables: Array.isArray(this.variables)\n          ? this.variables[0]\n          : this.variables,\n      })\n    },\n  },\n  created() {\n    if (!window._imageCache) {\n      window._imageCache = new ImageCache({ max: 200 })\n    }\n  },\n  updated() {\n    window._lozadObserver.observe()\n  },\n  mounted() {\n    // We initialize Lozad.js on the root\n    // element of our component.\n    if (!window._lozadObserver) {\n      window._lozadObserver = lozad('.rokka--attr-data-src', {\n        rootMargin: '200px',\n      })\n    }\n    window._lozadObserver.observe()\n  },\n}\n</script>\n\n<style scoped></style>\n","import RokkaImageImgLazy from './Img.vue'\n\nexport { RokkaImageImgLazy }\n\nexport default {\n  install(Vue) {\n    Vue.component('rokka-image-img-lazy', RokkaImageImgLazy)\n  },\n}\n"],"names":["isIE","document","documentMode","defaultConfig","rootMargin","threshold","[object Object]","element","nodeName","toLowerCase","img","createElement","getAttribute","src","alt","append","children","childs","childSrc","i","length","load","setAttribute","style","backgroundImage","split","join","imageSetLinks","firstUrlLink","substr","indexOf","classList","toggle","markAsLoaded","isLoaded","onIntersection","loaded","entries","observer","forEach","entry","intersectionRatio","isIntersecting","unobserve","target","getElements","selector","root","Element","NodeList","querySelectorAll","options","Object","assign","window","IntersectionObserver","elements","observe","css","ref","insertAt","head","getElementsByTagName","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","navigator","test","userAgent","template","script","scopeId","isFunctionalTemplate","moduleIdentifier","shadowMode","createInjector","createInjectorSSR","createInjectorShadow","hook","render","staticRenderFns","_compiled","functional","_scopeId","context","this","$vnode","ssrContext","parent","__VUE_SSR_CONTEXT__","call","_registeredComponents","add","_ssrRegister","$root","$options","shadowRoot","originalRender","h","existing","beforeCreate","concat","install","Vue","component","RokkaImageImgLazy"],"mappings":"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"}